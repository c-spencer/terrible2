(ns terrible.core)

(def list (lambda [& args]
  (List.apply nil args)))

(def symbol (lambda [name]
  (Symbol name)))

(var set-macro
  (lambda [f]
    (set! f.$macro true)
    f))

(def macro (set-macro
  (lambda [& body]
    `(set-macro (lambda ~@body)))))

(def defmacro
  (macro [name & body]
    `(def ~name (macro ~@body))))

(defmacro fn [& body]
  `(lambda ~@body))

(defmacro defn [name & body]
  `(def ~name (fn ~@body)))

(defmacro varfn [name & body]
  `(var ~name (fn ~@body)))

(defmacro setfn! [name & body]
  `(set! ~name (fn ~@body)))

(defn list? [l]
  (instance? l List))

(defn symbol? [s]
  (instance? s Symbol))

(defn keyword [name]
  (Keyword name))

(defn keyword? [k]
  (instance? k Keyword))

(defn string? [s]
  (= (type s) "string"))

(defn number? [s]
  (= (type s) "number"))

(defn object? [o]
  (and (not= nil o)
       (= (type o) "object")))

(defmacro cond [t v & cases]
  (if (and (keyword? t)
           (= t.name "else"))
    v
    (if (> cases.length 0)
      `(if ~t ~v (cond ~@cases))
      `(if ~t ~v))))

(defmacro let [bindings & body]
  (var vars [])
  (js-for [i 0] (< i bindings.length) (set! i (+ i 2))
    (var s (get bindings i)
         v (get bindings (+ i 1)))
    (vars.push `(var ~s ~v)))
  `(do ~@vars ~@body))

(defmacro -> [left app & apps]
  (cond
    (not app)       left
    (keyword? app) `(-> (get ~left ~app.name) ~@apps)
    (list? app)    `(-> (~app.values.0 ~left ~@(app.values.slice 1))
                        ~@apps)
    (symbol? app)  `(-> (~app ~left) ~@apps)
    :else           (throw "Invalid -> target")))

(defmacro defprotocol [symb & fns]
  (let [proto-marker (+ symb.name "$proto$")
        fn-defs (fns.map (fn [list]
                  (let [n       list.values.0
                        args    list.values.1
                        body   (list.values.slice 2)
                        marker (+ proto-marker n.name)]
                    `(defn ~n ~args
                      (if (get ~args.0 ~marker)
                        ((get ~args.0 ~marker) ~@args)
                        (do ~@body))))))]

    `(do-noscope
      (def ~symb ~proto-marker)
      ~@fn-defs)))

(defmacro extend-type [cls protocol & methods]
  `(do
    ~@(methods.map (fn [method]
      (let [n method.values.0]
       `(set!
          (get (get ~cls "prototype") (+ ~protocol ~n.name))
          (fn ~@(method.values.slice 1))))
      ))))

(defprotocol Iterable
  (map [obj func]
    (let [new-obj {}]
      (js-for-in k obj
        (if (obj.hasOwnProperty k)
          (set! (get new-obj k) (func (get obj k) k))))
      new-obj))
  (each [obj func]
    (js-for-in k obj
      (if (obj.hasOwnProperty k)
        (func (get obj k) k)))
    nil))

(extend-type Array Iterable
  (map [arr func] (arr.map func))
  (each [arr func] (arr.forEach func)))

(extend-type List Iterable
  (map [this-list func] (.concat (list) (this-list.values.map func)))
  (each [this-list func] (this-list.values.forEach func)))

(defprotocol Printable
  (print-str [obj]
    (cond
      (object? obj) (let [parts []]
                      (each obj (fn [v k]
                        (parts.push (print-str k))
                        (parts.push (print-str v))))
                      (+ "{" (parts.join " ") "}"))
      :else         (JSON.stringify obj))))

(extend-type Array Printable
  (print-str [arr]
    (+ "[" (.join (map arr print-str) " ") "]")))

(extend-type List Printable
  (print-str [list]
    (+ "(" (.values.join (map list print-str) " ") ")")))

(extend-type Keyword Printable
  (print-str [kw]
    (+ ":" kw.name)))

(extend-type Symbol Printable
  (print-str [symb] symb.name))

(extend-type Function Printable
  (print-str [f]
    (+ "#fn[" f.name "]")))
