(ns terrible.core)

; Required bindings assumed by macros

; needed early for var args
(var ^:external Array)

(var ^{:terr-macro true :private false} new
  (lambda [opts callee & args]
    (var walker (opts.walker opts.env))
    (opts.Terr.New (walker callee) (args.map walker))))

(var ^{:private false} list (lambda [& args]
  (new List args)))

(var ^{:private false} symbol (lambda [name]
  (new Symbol name)))

(var ^{:private false} keyword (lambda [name]
  (new Keyword name)))

(var ^{:terr-macro true :private false} def
  (lambda [opts id val]
    (set! id.$metadata (opts.extend id.$metadata {:private false}))
    (opts.builtins.var opts id val)))

(def ^:terr-macro quote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted "quote")) arg)))

(def ^:terr-macro syntax-quote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted "syntax")) arg)))

(def ^:terr-macro unquote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted false)) arg)))

(def ^:macro fn
  (lambda [& body]
    `(lambda ~@body)))

(def ^:macro defmacro
  (fn [name & body]
    (var macro-name (symbol name.name))
    (set! macro-name.$metadata {:macro true})
    `(def ~macro-name (fn ~@body))))

(defmacro extern [& symbs]
  (symbs.forEach (fn [s] (set! s.$metadata {:external true})))
  `(var ~@symbs))

; Grab some core JavaScript objects
(extern Function Object Number String JSON console)

(def ^:macro terr-macro
  (fn [name & body]
    (var macro-name (symbol name.name))
    (set! macro-name.$metadata {:terr-macro true})
    `(def ~macro-name (fn ~@body))))

; Useful utilities

(defmacro defn [name & body]
  `(def ~name (fn ~@body)))

; js operators

(defmacro binary-operator [symb op]
  `(terr-macro ~symb [opts# ~'& args#]
    (~'.reduce (args#.map (opts#.walker opts#.env))
      (fn [left# right#] (opts#.Terr.Binary left# ~op right#)))))

(defmacro unary-operator [symb op]
  `(terr-macro ~symb [opts# arg#]
    (opts#.Terr.Unary ~op ((opts#.walker opts#.env) arg#))))

(binary-operator + "+")
(binary-operator == "===")
(binary-operator ==? "==")
(binary-operator - "-")
(binary-operator not== "!==")
(binary-operator not==? "!=")
(binary-operator or "||")
(binary-operator and "&&")
(binary-operator > ">")
(binary-operator >= ">=")
(binary-operator < "<")
(binary-operator <= "<=")
(binary-operator / "/")
(binary-operator instance? "instanceof")
(binary-operator mod "%")

(unary-operator not "!")
(unary-operator xor "~")
(unary-operator type "typeof")

; Type checks

(defn list? [l]
  (instance? l List))

(defn symbol? [s]
  (instance? s Symbol))

(defn keyword? [k]
  (instance? k Keyword))

(defn string? [s]
  (== (type s) "string"))

(defn number? [s]
  (== (type s) "number"))

(defn object? [o]
  (and (not== nil o)
       (== (type o) "object")))

(defn vector? [v]
  (Array.isArray v))

; Core terr macros

(terr-macro if [opts test cons alt]
  (var walker (opts.walker opts.env))
  (opts.Terr.If (walker test) (walker cons) (walker alt)))

; Open a new logical scope, but not a new javascript scope, to allow block
; insertion to work as expected.
(terr-macro do [opts & body]
  (var walker (opts.walker (opts.env.newScope true false)))
  (opts.Terr.Seq (body.map walker)))

; As do, but no new scope.
; stop-gap until public vars can jump up scopes
(terr-macro do-noscope [opts & body]
  (var walker (opts.walker opts.env))
  (opts.Terr.Seq (body.map walker)))

(terr-macro get [opts target arg]
  (var walker (opts.walker opts.env))
  (opts.Terr.Member (walker target) (walker arg)))

(terr-macro return [opts arg]
  (opts.Terr.Return ((opts.walker opts.env) arg)))

(terr-macro throw [opts arg]
  (opts.Terr.Throw ((opts.walker opts.env) arg)))

; Refer a namespace into scope
(terr-macro refer [opts symb alias]
  (opts.env.scope.refer
    symb.name
    (if alias alias.name nil)
    (do
      (var ns (opts.env.env.findNamespace symb.name))
      (if ns ns
        (throw (+ "Couldn't resolve namespace `" symb.name "`")))))

  (opts.Terr.Seq []))

(terr-macro js-for [opts init test update & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (opts.Terr.For
    (walker `(var ~@init))
    (walker test)
    (walker update)
    (opts.Terr.Seq (body.map walker))))

(terr-macro js-for-in [opts left right & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (if (not (symbol? left))
    (throw "Left binding in js-for-in must be a symbol."))

  (opts.Terr.ForIn
    (walker `(var ~left))
    (walker right)
    (opts.Terr.Seq (body.map walker))))

(terr-macro js-while [opts test & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (opts.Terr.While
    (walker test)
    (opts.Terr.Seq (body.map walker))))

; Core library

(defmacro varfn [name & body]
  `(var ~name (fn ~@body)))

(defmacro setfn! [name & body]
  `(set! ~name (fn ~@body)))

(defmacro when [cond & body]
  `(if ~cond (do ~@body)))

(defmacro cond [t v & cases]
  (if (and (keyword? t)
           (== t.name "else"))
    v
    (if (> cases.length 0)
      `(if ~t ~v (cond ~@cases))
      `(if ~t ~v))))

(defmacro let [bindings & body]
  (var vars [])
  (js-for [i 0] (< i bindings.length) (set! i (+ i 2))
    (var s (get bindings i)
         v (get bindings (+ i 1)))
    (vars.push `(var ~s ~v)))
  `(do ~@vars ~@body))

(defmacro -> [left app & apps]
  (cond
    (not app)       left
    (keyword? app) `(-> (get ~left ~app.name) ~@apps)
    (list? app)    `(-> (~app.values.0 ~left ~@(app.values.slice 1))
                        ~@apps)
    (symbol? app)  `(-> (~app ~left) ~@apps)
    :else           (throw "Invalid -> target")))

(defmacro defprotocol [symb & fns]
  (let [proto-marker (+ symb.name "$proto$")
        fn-defs (fns.map (fn [list]
                  (let [n       list.values.0
                        args    list.values.1
                        body   (list.values.slice 2)
                        marker (+ proto-marker n.name)]
                    `(defn ~n ~args
                      (if (and (not==? nil ~args.0) (get ~args.0 ~marker))
                        ((get ~args.0 ~marker) ~@args)
                        (do ~@body))))))]
    `(do-noscope
      (def ~symb ~proto-marker)
      ~@fn-defs)))

(defmacro extend-type [cls protocol & methods]
  `(do
    ~@(methods.map (fn [method]
      (let [n method.values.0]
       `(set!
          (get (get ~cls "prototype") (+ ~protocol ~n.name))
          (fn ~@(method.values.slice 1))))
      ))))

(defprotocol Equality
  (= [left right]
    (== left right)))

; Avoid extra dispatch for not=
(defn not= [left right]
  (not (= left right)))

(extend-type Keyword Equality
  (= [left right]
    (and (keyword? right)
         (== left.name right.name))))

(extend-type Symbol Equality
  (= [left right]
    (and (symbol? right)
         (== left.name right.name))))

(defprotocol Iterable
  (map [obj func]
    (let [new-obj {}]
      (js-for-in k obj
        (if (obj.hasOwnProperty k)
          (set! (get new-obj k) (func (get obj k) k))))
      new-obj))
  (each [obj func]
    (js-for-in k obj
      (if (obj.hasOwnProperty k)
        (func (get obj k) k)))
    nil))

(extend-type Array Iterable
  (map [arr func] (arr.map func))
  (each [arr func] (arr.forEach func)))

(extend-type List Iterable
  (map [this-list func] (.concat (list) (this-list.values.map func)))
  (each [this-list func] (this-list.values.forEach func)))

(defprotocol Printable
  (print-str [obj]
    (cond
      (object? obj) (let [parts []]
                      (each obj (fn [v k]
                        (parts.push (print-str k))
                        (parts.push (print-str v))))
                      (+ "{" (parts.join " ") "}"))
      :else         (JSON.stringify obj))))

(extend-type Array Printable
  (print-str [arr]
    (+ "[" (.join (map arr print-str) " ") "]")))

(extend-type List Printable
  (print-str [list]
    (+ "(" (.values.join (map list print-str) " ") ")")))

(extend-type Keyword Printable
  (print-str [kw]
    (+ ":" kw.name)))

(extend-type Symbol Printable
  (print-str [symb] symb.name))

(extend-type Function Printable
  (print-str [f]
    (+ "#fn[" f.name "]")))

(terr-macro try [opts & body]
  (var walker opts.walker
       env opts.env
       catch-clause (body.pop))

  (if (or (not (list? catch-clause))
          (< catch-clause.values.length 2)
          (not= catch-clause.values.0 'catch)
          (not (symbol? catch-clause.values.1)))
    (throw "Invalid catch clause"))

  (var catch-arg catch_clause.values.1
       catch-body (catch-clause.values.slice 2)
       parsed-catch-arg (catch-arg.parse))

  (if (or (> parsed-catch-arg.parts.length 0)
          parsed-catch-arg.namespace)
    (throw "Invalid catch arg"))

  (var munged-name (opts.mungeSymbol parsed-catch-arg.root)
       catch-env (env.newScope true false))

  (catch-env.scope.addSymbol munged-name
    {:type "any"
     :accessor (opts.Terr.Identifier munged-name)
     :metadata {}})

  (opts.Terr.Try
    (opts.Terr.Seq (body.map (walker env)))
    (opts.Terr.Identifier munged-name)
    (opts.Terr.Seq (catch-body.map (walker catch-env)))))

; loop-recur scratchings

(terr-macro loop-body [opts & body]
  (let [loop-id (opts.Terr.Identifier "loop")]
    (set! opts.env.scope.js_frame.$loop loop-id)
    (let [mapped-body (body.map (opts.walker opts.env))]
      (if loop-id.$referenced
        (opts.Terr.Loop loop-id (opts.Terr.Seq mapped-body))
        (opts.Terr.Seq mapped-body)))))

(terr-macro recur [opts & args]
  (let [walker (opts.walker opts.env)
        assign (walker `(set! ~@args))]
    (set! opts.env.scope.js_frame.$loop.$referenced true)
    (opts.Terr.Seq [assign (opts.Terr.Continue opts.env.scope.js_frame.$loop)])))

(defmacro loop [bindings & body]
  `(let ~bindings (loop-body ~@body)))

; (loop [i 0]
;   (if (< i 10)
;     (do
;       (print i)
;       (recur i (+ i 1)))
;     i))

; (defn range [vec from to]
;   (loop-body
;     (cond
;       (< from to) (recur vec (vec.concat from) from (+ from 1))
;       (> from to) (recur vec (vec.concat from) from (- from 1))
;       (== from to) (vec.concat from))))

; (print (range [] 10 50))
