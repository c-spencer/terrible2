(ns terrible.core)

(def list (lambda [& args]
  (List.apply nil args)))

(def symbol (lambda [name]
  (Symbol name)))

(var set-macro
  (lambda [f]
    (set! f.$macro true)
    f))

(def macro (set-macro
  (lambda [& body]
    `(set-macro (lambda ~@body)))))

(def defmacro
  (macro [name & body]
    `(def ~name (macro ~@body))))

(defmacro fn [& body]
  `(lambda ~@body))

(defmacro defn [name & body]
  `(def ~name (fn ~@body)))

(defmacro varfn [name & body]
  `(var ~name (fn ~@body)))

(defmacro setfn! [name & body]
  `(set! ~name (fn ~@body)))

(defn list? [l]
  (instance? l List))

(defn symbol? [s]
  (instance? s Symbol))

(defn keyword [name]
  (Keyword name))

(defn keyword? [k]
  (instance? k Keyword))

(defmacro cond [t v & cases]
  (if (and (keyword? t)
           (= t.name "else"))
    v
    (if (> cases.length 0)
      `(if ~t ~v (cond ~@cases))
      `(if ~t ~v))))

(defmacro let [bindings & body]
  (var vars [])
  (js-for [i 0] (< i bindings.length) (set! i (+ i 2))
    (var s (get bindings i)
         v (get bindings (+ i 1)))
    (vars.push `(var ~s ~v)))
  `(do ~@vars ~@body))

(defmacro -> [left app & apps]
  (cond
    (not app)       left
    (keyword? app) `(-> (get ~left ~app.name) ~@apps)
    (list? app)    `(-> (~app.values.0 ~left ~@(app.values.slice 1))
                        ~@apps)
    (symbol? app)  `(-> (~app ~left) ~@apps)
    :else           (throw "Invalid -> target")))

; (defmacro defprotocol [symb & fns]
;   (let [marker (+ symb.name "$proto")
;         first (fn [list] list.values.0)
;         name (fn [symb] symb.name)
;         fn-names (-> fns (.map first) (.map name))
;         defaults {}]
;     (fn-names.forEach (fn [n]
;       (set! (get defaults (+ "default$" n)) nil)))
;     `(def ~symb ~defaults)))

; ; declaration
; (defprotocol Iterable
;   (map [obj func])
;   (each [obj func]))

; ; expansion
; (def Iterable
;   { :$default$map nil
;     :$default$each nil })

; (defn map [obj func]
;   (cond
;     obj.Iterable$proto$map (obj.Iterable$proto$map obj func)
;     Iterable.$default$map (Iterable.$default$map obj func)
;     :else (throw "No suitable implementation of Iterable map$2 found.")))

; (defn each [obj func]
;   (cond
;     obj.Iterable$proto$each (obj.Iterable$proto$each obj func)
;     Iterable.$default$each (Iterable.$default$each obj func)
;     :else (throw "No suitable implementation of Iterable each$2 found.")))
