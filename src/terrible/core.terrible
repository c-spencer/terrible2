(ns terrible.core)

(def list (lambda [& args]
  (List.apply nil args)))

(def symbol (lambda [name]
  (Symbol name)))

(var set-macro
  (lambda [f]
    (set! f.$macro true)
    f))

(def macro (set-macro
  (lambda [& body]
    `(set-macro (lambda ~@body)))))

(def defmacro
  (macro [name & body]
    `(def ~name (macro ~@body))))

(defmacro fn [& body]
  `(lambda ~@body))

(defmacro defn [name & body]
  `(def ~name (fn ~@body)))

(defmacro varfn [name & body]
  `(var ~name (fn ~@body)))

(defmacro setfn! [name & body]
  `(set! ~name (fn ~@body)))

(defn list? [l]
  (instance? l List))

(defn symbol? [s]
  (instance? s Symbol))

(defn keyword [name]
  (Keyword name))

(defn keyword? [k]
  (instance? k Keyword))

(defmacro cond [& cases]
  (if (and (keyword? cases.0)
           (= cases.0.name "else"))
    cases.1
    (if cases.2
      `(if ~cases.0 ~cases.1 (cond ~@(cases.slice 2)))
      `(if ~cases.0 ~cases.1))))

; might need some other supporting functionality before protocols
; like loops..

; (defmacro defprotocol [name & fns]
;   (var marker (symbol (+ name.name "$proto")))
;   (print marker)

;   `(do
;     ~@(fns.map
;       (fn [list]
;         `(defn ~list.values.0 ~list.values.1 (+ 1 2))
;   ))))

; (defprotocol Iterable
;   (map [obj func])
;   (each [obj func]))

(defmacro let [bindings & body]
  (var vars [])
  ; I really need to add iteration somewhere..
  (bindings.forEach (fn [v i]
    (if (not (mod i 2))
      (vars.push `(var ~v ~(get bindings (+ i 1))))
  )))
  `(do ~@vars ~@body))
