(ns terrible.core)

; Required bindings assumed by macros

(var ^{:private false} list (lambda [& args]
  (List.apply nil args)))

(var ^{:private false} symbol (lambda [name]
  (Symbol name)))

(var ^{:private false} keyword (lambda [name]
  (Keyword name)))

(var ^{:terr-macro true :private false} def (lambda [opts id val]
  (set! id.$metadata (opts.extend id.$metadata {:private false}))
  (opts.builtins.var opts id val)))

(def ^:terr-macro quote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted "quote")) arg)))

(def ^:terr-macro syntax-quote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted "syntax")) arg)))

(def ^:terr-macro unquote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted false)) arg)))

(def ^:macro fn
  (lambda [& body]
    `(lambda ~@body)))

(def ^:macro defmacro
  (fn [name & body]
    (var macro-name (symbol name.name))
    (set! macro-name.$metadata {:macro true})
    `(def ~macro-name (fn ~@body))))

(def ^:macro terr-macro
  (fn [name & body]
    (var macro-name (symbol name.name))
    (set! macro-name.$metadata {:terr-macro true})
    `(def ~macro-name (fn ~@body))))

; Useful utilities

(defmacro defn [name & body]
  `(def ~name (fn ~@body)))

; js operators

(defmacro binary-operator [symb op]
  `(terr-macro ~symb [opts# ~'& args#]
    (~'.reduce (args#.map (opts#.walker opts#.env))
      (fn [left# right#] (opts#.Terr.Binary left# ~op right#)))))

(defmacro unary-operator [symb op]
  `(terr-macro ~symb [opts# arg#]
    (opts#.Terr.Unary ~op ((opts#.walker opts#.env) arg#))))

(binary-operator + "+")
(binary-operator = "===")
(binary-operator - "-")
(binary-operator not= "!==")
(binary-operator or "||")
(binary-operator and "&&")
(binary-operator > ">")
(binary-operator >= ">=")
(binary-operator < "<")
(binary-operator <= "<=")
(binary-operator / "/")
(binary-operator instance? "instanceof")
(binary-operator mod "%")

(unary-operator not "!")
(unary-operator xor "~")
(unary-operator type "typeof")

; Type checks

(defn list? [l]
  (instance? l List))

(defn symbol? [s]
  (instance? s Symbol))

(defn keyword? [k]
  (instance? k Keyword))

(defn string? [s]
  (= (type s) "string"))

(defn number? [s]
  (= (type s) "number"))

(defn object? [o]
  (and (not= nil o)
       (= (type o) "object")))

; Core terr macros

(terr-macro if [opts test cons alt]
  (var walker (opts.walker opts.env))

  (opts.Terr.If (walker test) (walker cons) (walker alt)))

(terr-macro throw [opts arg]
  (opts.Terr.Throw ((opts.walker opts.env) arg)))

(terr-macro js-for [opts init test update & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (opts.Terr.For
    (walker `(var ~@init))
    (walker test)
    (walker update)
    (opts.Terr.Seq (body.map walker))))

(terr-macro js-for-in [opts left right & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (if (not (symbol? left))
    (throw "Left binding in js-for-in must be a symbol."))

  (opts.Terr.ForIn
    (walker `(var ~left))
    (walker right)
    (opts.Terr.Seq (body.map walker))))

; Core library

(defmacro varfn [name & body]
  `(var ~name (fn ~@body)))

(defmacro setfn! [name & body]
  `(set! ~name (fn ~@body)))

(defmacro when [cond & body]
  `(if ~cond (do ~@body)))

(defmacro cond [t v & cases]
  (if (and (keyword? t)
           (= t.name "else"))
    v
    (if (> cases.length 0)
      `(if ~t ~v (cond ~@cases))
      `(if ~t ~v))))

(defmacro let [bindings & body]
  (var vars [])
  (js-for [i 0] (< i bindings.length) (set! i (+ i 2))
    (var s (get bindings i)
         v (get bindings (+ i 1)))
    (vars.push `(var ~s ~v)))
  `(do ~@vars ~@body))

(defmacro -> [left app & apps]
  (cond
    (not app)       left
    (keyword? app) `(-> (get ~left ~app.name) ~@apps)
    (list? app)    `(-> (~app.values.0 ~left ~@(app.values.slice 1))
                        ~@apps)
    (symbol? app)  `(-> (~app ~left) ~@apps)
    :else           (throw "Invalid -> target")))

(defmacro defprotocol [symb & fns]
  (let [proto-marker (+ symb.name "$proto$")
        fn-defs (fns.map (fn [list]
                  (let [n       list.values.0
                        args    list.values.1
                        body   (list.values.slice 2)
                        marker (+ proto-marker n.name)]
                    `(defn ~n ~args
                      (if (get ~args.0 ~marker)
                        ((get ~args.0 ~marker) ~@args)
                        (do ~@body))))))]

    `(do-noscope
      (def ~symb ~proto-marker)
      ~@fn-defs)))

(defmacro extend-type [cls protocol & methods]
  `(do
    ~@(methods.map (fn [method]
      (let [n method.values.0]
       `(set!
          (get (get ~cls "prototype") (+ ~protocol ~n.name))
          (fn ~@(method.values.slice 1))))
      ))))

(defprotocol Iterable
  (map [obj func]
    (let [new-obj {}]
      (js-for-in k obj
        (if (obj.hasOwnProperty k)
          (set! (get new-obj k) (func (get obj k) k))))
      new-obj))
  (each [obj func]
    (js-for-in k obj
      (if (obj.hasOwnProperty k)
        (func (get obj k) k)))
    nil))

(extend-type Array Iterable
  (map [arr func] (arr.map func))
  (each [arr func] (arr.forEach func)))

(extend-type List Iterable
  (map [this-list func] (.concat (list) (this-list.values.map func)))
  (each [this-list func] (this-list.values.forEach func)))

(defprotocol Printable
  (print-str [obj]
    (cond
      (object? obj) (let [parts []]
                      (each obj (fn [v k]
                        (parts.push (print-str k))
                        (parts.push (print-str v))))
                      (+ "{" (parts.join " ") "}"))
      :else         (JSON.stringify obj))))

(extend-type Array Printable
  (print-str [arr]
    (+ "[" (.join (map arr print-str) " ") "]")))

(extend-type List Printable
  (print-str [list]
    (+ "(" (.values.join (map list print-str) " ") ")")))

(extend-type Keyword Printable
  (print-str [kw]
    (+ ":" kw.name)))

(extend-type Symbol Printable
  (print-str [symb] symb.name))

(extend-type Function Printable
  (print-str [f]
    (+ "#fn[" f.name "]")))
