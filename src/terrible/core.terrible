(ns terrible.core)

; Required bindings assumed by macros

(var ^:external Array) ; needed early for var args

(var ^{:terr-macro true :private false} new
  (lambda [opts callee & args]
    (var walker (opts.walker opts.env))
    (opts.Terr.New (walker callee) (args.map walker))))

(var ^{:private false} list (lambda [& args]
  (new List args)))

(var ^{:private false} symbol (lambda [name]
  (new Symbol name)))

(var ^{:private false} keyword (lambda [name]
  (new Keyword name)))

(var ^{:terr-macro true :private false} def
  (lambda [opts id val]
    (set! id.$metadata (opts.extend id.$metadata {:private false}))
    (opts.builtins.var opts id val)))

(def ^:terr-macro quote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted "quote")) arg)))

(def ^:terr-macro syntax-quote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted "syntax")) arg)))

(def ^:terr-macro unquote
  (lambda [opts arg]
    ((opts.walker (opts.env.setQuoted false)) arg)))

; terr-macros bootstrapping

(def ^:macro terr-macro
  (lambda [name & body]
    (var macro-name (symbol name.name))
    (set! macro-name.$metadata {:terr-macro true})
    `(def ~macro-name (lambda ~@body))))

(var ^:macro defmacro-lambda
  (lambda [name & body]
    (var macro-name (symbol name.name))
    (set! macro-name.$metadata {:macro true})
    `(var ~macro-name (lambda ~@body))))

(defmacro-lambda deflambda [name & body]
  `(def ~name (lambda ~@body)))

; js operators

(defmacro-lambda binary-operator [symb op]
  `(terr-macro ~symb [opts# ~'& args#]
    (~'.reduce (args#.map (opts#.walker opts#.env))
      (lambda [left# right#] (opts#.Terr.Binary left# ~op right#)))))

(defmacro-lambda unary-operator [symb op]
  `(terr-macro ~symb [opts# arg#]
    (opts#.Terr.Unary ~op ((opts#.walker opts#.env) arg#))))

(binary-operator + "+")
(binary-operator == "===")
(binary-operator ==? "==")
(binary-operator - "-")
(binary-operator not== "!==")
(binary-operator not==? "!=")
(binary-operator or "||")
(binary-operator and "&&")
(binary-operator > ">")
(binary-operator >= ">=")
(binary-operator < "<")
(binary-operator <= "<=")
(binary-operator / "/")
(binary-operator instance? "instanceof")
(binary-operator mod "%")

(unary-operator not "!")
(unary-operator xor "~")
(unary-operator type "typeof")

; Type checks

(deflambda list? [l]
  (instance? l List))

(deflambda symbol? [s]
  (instance? s Symbol))

(deflambda keyword? [k]
  (instance? k Keyword))

(deflambda string? [s]
  (== (type s) "string"))

(deflambda number? [s]
  (== (type s) "number"))

(deflambda object? [o]
  (and (not== nil o)
       (== (type o) "object")))

(deflambda vector? [v]
  (Array.isArray v))

; fn bootstrapping

(terr-macro if [opts test cons alt]
  (var walker (opts.walker opts.env))
  (opts.Terr.If (walker test) (walker cons) (walker alt)))

; Open a new logical scope, but not a new javascript scope, to allow block
; insertion to work as expected.
(terr-macro do [opts & body]
  (var walker (opts.walker (opts.env.newScope true false)))
  (opts.Terr.Seq (body.map walker)))

; As do, but no new scope.
; stop-gap until public vars can jump up scopes
(terr-macro do-noscope [opts & body]
  (var walker (opts.walker opts.env))
  (opts.Terr.Seq (body.map walker)))

(terr-macro throw [opts arg]
  (opts.Terr.Throw ((opts.walker opts.env) arg)))

(terr-macro loop-body [opts & body]
  (var loop-id (opts.Terr.Identifier "loop"))
  (set! opts.env.scope.js_frame.$loop loop-id)
  (var mapped-body (body.map (opts.walker opts.env)))
  (if loop-id.$referenced
    (opts.Terr.Loop loop-id (opts.Terr.Seq mapped-body))
    (opts.Terr.Seq mapped-body)))

(terr-macro recur [opts & args]
  (if opts.env.scope.js_frame.$loop
    (do (set! opts.env.scope.js_frame.$loop.$referenced true)
        (opts.Terr.Seq [((opts.walker opts.env) `(set! ~@args))
                        (opts.Terr.Continue opts.env.scope.js_frame.$loop)]))
    (throw "Must call recur from a loop-body context.")))

(terr-macro get [opts target arg]
  (var walker (opts.walker opts.env))
  (opts.Terr.Member (walker target) (walker arg)))

(def ^:macro cond
  (lambda [t v & cases]
    (if (and (keyword? t)
             (== t.name "else"))
      v
      (if (> cases.length 0)
        `(if ~t ~v (cond ~@cases))
        `(if ~t ~v)))))

(def ^:macro destructure
  (lambda [left right]
    (cond (symbol? left) `(var ~left ~right)
          (list? left) `(destructure ~left.values (get ~right "values"))
          (vector? left)
            (do
              (var bindings []
                   i 0)
              (loop-body
                (if (< i left.length)
                  (do
                    (var l (get left i))
                    (if (and (symbol? l) (== l.name "&"))
                      (bindings.push
                        `(destructure ~(get left (+ i 1))
                                      (Array.prototype.slice.call ~right ~i)))
                      (do
                        (bindings.push `(destructure ~l (get ~right ~i)))
                        (recur i (+ i 1))))
                    )))
              `(do-noscope ~@bindings))
          :else (throw "Unsupported destructuring form"))))

(deflambda analyse-fn-args [args]
  (var formal-args []
       destructure-pairs [])

  (args.forEach (lambda [arg i]
    (if (symbol? arg)
      (formal-args.push arg)
      (do
        (var new-symb (symbol (+ "arg_" i "#")))
        (formal-args.push new-symb)
        (destructure-pairs.push `(destructure ~arg ~new-symb))))))

  {:formal formal-args
   :destructure destructure-pairs})

(def ^:macro fn
  (lambda [& body]
    (var extract (lambda [v]
      (var fn-args (analyse-fn-args v.0))
      `[~(get fn-args "formal") (loop-body ~@(get fn-args "destructure")
                                           ~@(v.slice 1))]
    ))
    (if (list? body.0)
      `(lambda ~@(body.map (lambda [v] `(~@(extract v.values)))))
      `(lambda ~@(extract body)))))

(def ^:macro defmacro
  (fn [name & body]
    (var macro-name (symbol name.name))
    (set! macro-name.$metadata {:macro true})
    `(def ~macro-name (fn ~@body))))

(defmacro defn [name & body]
  `(def ~name (fn ~@body)))

(defmacro extern [& symbs]
  (symbs.forEach (fn [s] (set! s.$metadata {:external true})))
  `(var ~@symbs))

; Grab some core JavaScript objects
(extern Function Object Number String JSON console)

; Core terr macros

(terr-macro return [opts arg]
  (opts.Terr.Return ((opts.walker opts.env) arg)))

; Refer a namespace into scope
(terr-macro refer [opts symb alias]
  (opts.env.scope.refer
    symb.name
    (if alias alias.name nil)
    (do
      (var ns (opts.env.env.findNamespace symb.name))
      (if ns ns
        (throw (+ "Couldn't resolve namespace `" symb.name "`")))))

  (opts.Terr.Seq []))

(terr-macro js-for [opts init test update & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (opts.Terr.For
    (walker `(var ~@init))
    (walker test)
    (walker update)
    (opts.Terr.Seq (body.map walker))))

(terr-macro js-for-in [opts left right & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (if (not (symbol? left))
    (throw "Left binding in js-for-in must be a symbol."))

  (opts.Terr.ForIn
    (walker `(var ~left))
    (walker right)
    (opts.Terr.Seq (body.map walker))))

(terr-macro js-while [opts test & body]
  (var env (opts.env.newScope true false)
       walker (opts.walker env))

  (opts.Terr.While
    (walker test)
    (opts.Terr.Seq (body.map walker))))

; Core library

(defmacro varfn [name & body]
  `(var ~name (fn ~@body)))

(defmacro setfn! [name & body]
  `(set! ~name (fn ~@body)))

(defmacro when [cond & body]
  `(if ~cond (do ~@body)))

(defmacro let [bindings & body]
  (var vars [])
  (js-for [i 0] (< i bindings.length) (set! i (+ i 2))
    (var s (get bindings i)
         v (get bindings (+ i 1)))
    (if (symbol? s)
      (vars.push `(var ~s ~v))
      (do
        (var new-symb (symbol (+ "let_" i "#")))
        (vars.push `(var ~new-symb ~v))
        (vars.push `(destructure ~s ~new-symb)))))
  `(do ~@vars ~@body))

(defmacro loop [bindings & body]
  `(let ~bindings (loop-body ~@body)))

(defmacro -> [left app & apps]
  (cond
    (not app)       left
    (keyword? app) `(-> (get ~left ~app.name) ~@apps)
    (list? app)    `(-> (~app.values.0 ~left ~@(app.values.slice 1))
                        ~@apps)
    (symbol? app)  `(-> (~app ~left) ~@apps)
    :else           (throw "Invalid -> target")))

(defmacro defprotocol [symb & fns]
  (let [proto-marker (+ symb.name "$proto$")
        fn-defs (fns.map (fn [list]
                  (let [n       list.values.0
                        args    list.values.1
                        body   (list.values.slice 2)
                        marker (+ proto-marker n.name)]
                    `(defn ~n ~args
                      (if (and (not==? nil ~args.0) (get ~args.0 ~marker))
                        ((get ~args.0 ~marker) ~@args)
                        (do ~@body))))))]
    `(do-noscope
      (def ~symb ~proto-marker)
      ~@fn-defs)))

(defmacro extend-type [cls protocol & methods]
  `(do
    ~@(methods.map (fn [method]
      (let [n method.values.0]
       `(set!
          (get (get ~cls "prototype") (+ ~protocol ~n.name))
          (fn ~@(method.values.slice 1))))
      ))))

(defprotocol Equality
  (= [left right]
    (== left right)))

; Avoid extra dispatch for not=
(defn not= [left right]
  (not (= left right)))

(extend-type Keyword Equality
  (= [left right]
    (and (keyword? right)
         (== left.name right.name))))

(extend-type Symbol Equality
  (= [left right]
    (and (symbol? right)
         (== left.name right.name))))

(defprotocol Iterable
  (map [obj func]
    (let [new-obj {}]
      (js-for-in k obj
        (if (obj.hasOwnProperty k)
          (set! (get new-obj k) (func (get obj k) k))))
      new-obj))
  (each [obj func]
    (js-for-in k obj
      (if (obj.hasOwnProperty k)
        (func (get obj k) k)))
    nil))

(extend-type Array Iterable
  (map [arr func] (arr.map func))
  (each [arr func] (arr.forEach func)))

(extend-type List Iterable
  (map [this-list func] (.concat (list) (this-list.values.map func)))
  (each [this-list func] (this-list.values.forEach func)))

(defprotocol Printable
  (print-str [obj]
    (cond
      (object? obj) (let [parts []]
                      (each obj (fn [v k]
                        (parts.push (print-str k))
                        (parts.push (print-str v))))
                      (+ "{" (parts.join " ") "}"))
      :else         (JSON.stringify obj))))

(extend-type Array Printable
  (print-str [arr]
    (+ "[" (.join (map arr print-str) " ") "]")))

(extend-type List Printable
  (print-str [list]
    (+ "(" (.values.join (map list print-str) " ") ")")))

(extend-type Keyword Printable
  (print-str [kw]
    (+ ":" kw.name)))

(extend-type Symbol Printable
  (print-str [symb] symb.name))

(extend-type Function Printable
  (print-str [f]
    (+ "#fn[" f.name "]")))

(terr-macro try [opts & body]
  (var walker opts.walker
       env opts.env
       catch-clause (body.pop))

  (if (or (not (list? catch-clause))
          (< catch-clause.values.length 2)
          (not= catch-clause.values.0 'catch)
          (not (symbol? catch-clause.values.1)))
    (throw "Invalid catch clause"))

  (var catch-arg catch_clause.values.1
       catch-body (catch-clause.values.slice 2)
       parsed-catch-arg (catch-arg.parse))

  (if (or (> parsed-catch-arg.parts.length 0)
          parsed-catch-arg.namespace)
    (throw "Invalid catch arg"))

  (var munged-name (opts.mungeSymbol parsed-catch-arg.root)
       catch-env (env.newScope true false))

  (catch-env.scope.addSymbol munged-name
    {:type "any"
     :accessor (opts.Terr.Identifier munged-name)
     :metadata {}})

  (opts.Terr.Try
    (opts.Terr.Seq (body.map (walker env)))
    (opts.Terr.Identifier munged-name)
    (opts.Terr.Seq (catch-body.map (walker catch-env)))))
